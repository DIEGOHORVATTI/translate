{"version":3,"sources":["../../../../src/modules/translate/shared/translatte.ts"],"sourcesContent":["/* eslint-disable */\nimport axios from 'axios'\n\n// @ts-ignore\nimport { fetchToken } from './token'\nimport { SupportedLanguage, utf8Length } from './languages'\n\nexport type TranslationOptions = {\n  text: string\n  from: SupportedLanguage\n  to: SupportedLanguage\n}\n\n/**\n * @param {Props} props\n * @description Função que traduz um texto de um idioma para outro\n * @description A função suporta textos com marcadores {{}} que não devem ser traduzidos\n * @returns {Promise<string>}\n * @throws {Error}\n * @example translatte({ text: 'teste de parametros por colchetes {{notTraduction}}', to: 'en', from: 'pt-br' })\n */\nexport const translatte = async ({ text, from, to }: TranslationOptions): Promise<string> => {\n  const errors = [\n    'The language «[lang]» is not supported',\n    'Text must not exceed 5000 bytes',\n    'The server returned an empty response',\n    'Could not get token from google',\n    'Text translation request failed'\n  ]\n\n  const bytes = utf8Length(text)\n\n  if (bytes > 5000) {\n    const chars = Math.ceil(text.length / Math.ceil(bytes / 4700)) + 100\n    let plain = ' ' + text + ' '\n    let texts: any[] = []\n    let j = 0\n\n    ;['.', ',', ' '].forEach(separator => {\n      if (!plain) return\n      const split = plain.split(separator)\n      for (let i = 0, l = split.length; i < l; i++) {\n        if (!texts[j]) texts[j] = []\n        if ((texts[j].join(separator) + split[i]).length < chars) {\n          texts[j].push(split[i])\n          plain = split.slice(i + 1).join(separator)\n        } else {\n          if (!texts[j].length) break\n          texts[j].push('')\n          texts[++j] = []\n          if ((texts[j].join(separator) + split[i]).length < chars) {\n            texts[j].push(split[i])\n            plain = split.slice(i + 1).join(separator)\n          } else {\n            break\n          }\n        }\n      }\n      texts = texts\n        .map(t => {\n          if (!t) return ''\n\n          if (typeof t === 'object') {\n            return t.join(separator).trim()\n          } else if (typeof t === 'string') {\n            return t.trim()\n          }\n\n          return ''\n        })\n        .filter(Boolean)\n    })\n\n    if (!texts || !texts.length) return Promise.reject(new Error(errors[1]))\n\n    return texts.reduce((p, text) => {\n      return p.then((prev: { text: string }) => {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            translatte({ text, from, to })\n              .then(text => {\n                if (!text) return reject(errors[2])\n\n                text = prev && prev.text ? prev.text + ' ' + text : text\n\n                return resolve(text)\n              })\n              .catch(e => reject(e))\n          }, 1000)\n        })\n      })\n    }, Promise.resolve())\n  }\n\n  // Substituir marcadores temporários\n  const placeholders: Record<string, string> = {}\n\n  // Não traduzir os textos que estão dentro do {{}} pois são variáveis\n  const translatedText = text.replace(/{{(.*?)}}/g, match => {\n    const placeholder = `{{${Object.keys(placeholders).length}}}`\n    placeholders[placeholder] = match // Armazena o valor original\n\n    return placeholder // Substitui pelo marcador\n  })\n\n  try {\n    const tk = fetchToken(translatedText)\n    if (!tk) throw new Error(errors[3])\n\n    const params = new URLSearchParams({ tk, client: 'gtx', q: translatedText, sl: from, tl: to })\n    params.append('dt', 't')\n\n    const { data } = await axios.get<Array<Array<string>>>(`https://translate.google.com/translate_a/single?${params}`)\n\n    let translateText = data[0].map(obj => obj[0] || '').join('')\n\n    // Restaura os marcadores com os valores originais\n    for (const [placeholder, value] of Object.entries(placeholders)) {\n      translateText = translateText.replace(placeholder, value)\n    }\n\n    return translateText\n  } catch (error) {\n    return Promise.reject(error)\n  }\n}\n"],"names":["translatte","text","from","to","errors","bytes","utf8Length","chars","Math","ceil","length","plain","texts","j","forEach","separator","split","i","l","join","push","slice","map","t","trim","filter","Boolean","Promise","reject","Error","reduce","p","then","prev","resolve","setTimeout","catch","e","placeholders","translatedText","replace","match","placeholder","Object","keys","tk","fetchToken","params","URLSearchParams","client","q","sl","tl","append","data","axios","get","translateText","obj","value","entries","error"],"mappings":"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"}